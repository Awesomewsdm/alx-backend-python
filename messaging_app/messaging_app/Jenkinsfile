/*
Declarative Jenkins Pipeline for the messaging_app

Requirements & Notes:
- Start Jenkins locally (docker):
  docker run -d --name jenkins -p 8080:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts
- Install required plugins in Jenkins UI: Git plugin, Pipeline, ShiningPanda (optional if you want Python virtualenv steps via Jenkins UI).
- Add a Jenkins credential with ID `github-creds` that has access to the repository (username/password or personal access token). If repo is public, credentials are optional.
- This Pipeline will run on a Jenkins agent that supports shell (Linux). If you use a Windows agent, change shell steps accordingly.
- The pipeline checks out the repository, changes into the `messaging_app` directory, creates a venv, installs requirements, runs pytest and publishes test results (JUnit XML).

Adjust the `credentialsId` value if you used a different ID in Jenkins credentials.
*/

pipeline {
  agent any

  environment {
    GIT_URL = 'https://github.com/Awesomewsdm/alx-backend-python.git'
    REPO_SUBDIR = 'messaging_app'
    # Change this to the credentials ID you create in Jenkins (username/password or token)
    GIT_CREDENTIALS = 'github-creds'
    // Docker Hub image name (change to your Docker Hub repo)
    DOCKER_IMAGE = 'your-dockerhub-username/messaging-app'
    DOCKER_CREDENTIALS = 'dockerhub-creds'
  }

  options {
    // keep builds around for some days if you want
    buildDiscarder(logRotator(numToKeepStr: '30'))
    timestamps()
  }

  stages {
    stage('Checkout') {
      steps {
        // Checkout the repo using Jenkins-provided git step and credentials
        echo "Checking out ${GIT_URL}"
        git branch: 'main', url: "${GIT_URL}", credentialsId: "${GIT_CREDENTIALS}"
      }
    }

    stage('Setup Python') {
      steps {
        // create venv inside the messaging_app subfolder and install deps using pip3
        sh '''
        set -e
        echo "Creating venv in messaging_app/venv..."
        python3 -m venv messaging_app/venv || python -m venv messaging_app/venv
        . messaging_app/venv/bin/activate
        pip3 install --upgrade pip
        # install test deps from messaging_app/requirements.txt if present
        if [ -f messaging_app/requirements.txt ]; then
          pip3 install -r messaging_app/requirements.txt || true
        fi
        pip3 install pytest pytest-cov junit-xml || true
        '''
      }
    }

    stage('Run Tests') {
      steps {
        dir("${REPO_SUBDIR}") {
          sh '''
          set -e
          # activate the venv created in messaging_app/venv
          . venv/bin/activate
          mkdir -p reports
          # Run pytest and output JUnit xml for Jenkins to pick up
          pytest -q --junitxml=reports/junit.xml || true
          '''
        }
      }
      post {
        always {
          // Archive and publish test results
          junit "${REPO_SUBDIR}/reports/junit.xml"
          archiveArtifacts artifacts: "${REPO_SUBDIR}/reports/**", allowEmptyArchive: true
        }
      }
    }

    stage('Optional: Package / Build image') {
      when {
        expression { return true }
      }
      steps {
        // Build and push image to Docker Hub using credentials stored in Jenkins
        withCredentials([usernamePassword(credentialsId: "${DOCKER_CREDENTIALS}", usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PWD')]) {
          sh '''
          set -e
          TAG=${BUILD_NUMBER:-latest}
          echo "Building Docker image ${DOCKER_IMAGE}:${TAG}"
          docker build -t ${DOCKER_IMAGE}:${TAG} ./messaging_app
          echo $DOCKER_PWD | docker login -u $DOCKER_USER --password-stdin
          docker push ${DOCKER_IMAGE}:${TAG}
          '''
        }
      }
    }
  }

  post {
    success {
      echo 'Pipeline succeeded.'
    }
    failure {
      echo 'Pipeline failed. Check test reports and console output.'
    }
  }
}
